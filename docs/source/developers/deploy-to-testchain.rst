*******************
Deploy to Testchain
*******************

Step 1: Create account on Testchain
===================================

The |faucet_bot_reference| helps you with getting set up and creating an account with some tokens in it. With the help
of this bot you will get the following data about your testnet account:

1. Account name;
2. Public and private keys to be able to create transactions.

.. image:: /img/faucet/bot-example.gif
   :width: 100%
   :align: center
   :alt: Bot usage example

.. |faucet_bot_reference| raw:: html

   <a href="https://t.me/RemmeProtocolTestnetFaucetBot" target="_blank">Faucet bot</a>

Step 2: Import Private Key to Wallet
====================================
After account creation, import the private key generated by the |faucet_bot_reference|.

.. code-block:: console

    $ remcli wallet import

Then, paste your private key.

Step 3: Create Contract Account
===============================

.. note::
    To get new tokens on ``Testchain`` you should click on |faucet_bot_reference| ``Request a new batch of tokens``. This is necessary to create an contract account.

.. topic::
    To create new account on ``Testchain`` use ``remcli sysytem newaccount``:

    **Usage:** ``remcli system newaccount [OPTIONS] creator name OwnerKey [ActiveKey]``

    Positionals:
      -creator                The name of the account creating the new account (required)
      -name                   The name of the new account (required)
      -OwnerKey               The owner public key or permission level for the new account (required)
      -ActiveKey              The active public key or permission level for the new account

    **Options:**

    .. code-block:: bash

          -h,--help                   Print this help message and exit
          --stake TEXT                The amount of tokens delegated for resources (required)
          --transfer                  Transfer voting power and right to unstake tokens to receiver
          -x,--expiration             set the time in seconds before a transaction expires, defaults to 30s
          -f,--force-unique           force the transaction to be unique. this will consume extra bandwidth and remove any protections against accidently issuing the same transaction multiple times
          -s,--skip-sign              Specify if unlocked wallet keys should be used to sign transaction
          -j,--json                   print result as json
          --json-file TEXT            save result in json format into a file
          -d,--dont-broadcast         don't broadcast transaction to the network (just print to stdout)
          --return-packed             used in conjunction with --dont-broadcast to get the packed transaction
          -r,--ref-block TEXT         set the reference block num or block id used for TAPOS (Transaction as Proof-of-Stake)
          --use-old-rpc               use old RPC push_transaction, rather than new RPC send_transaction
          -p,--permission TEXT ...    An account and permission level to authorize, as in 'account@permission' (defaults to 'creator@active')
          --max-cpu-usage-ms UINT     set an upper limit on the milliseconds of cpu usage budget, for the execution of the transaction (defaults to 0 which means no limit)
          --max-net-usage UINT        set an upper limit on the net usage budget, in bytes, for the transaction (defaults to 0 which means no limit)
          --delay-sec UINT            set the delay_sec seconds, defaults to 0s

**First, create a new key pair:**

.. code-block:: console

    $ remclit create key --to-console

**Then import them:**

.. code-block:: console

    $ remclit wallet import

.. note::
    Before creating a contract account, unlock your wallet.

**Let's create a contract account and stake** ``1000.0000 REM``:

.. code-block:: console

    $ remcli -u https://testchain.remme.io/ system newaccount CREATOR namevalidatr PUBLIC_KEY --stake "1000.0000 REM" --transfer

-u      this is a flag that indicates the address of the node to which your transaction will be sent.

It will return something like:

.. code-block:: bash

    executed transaction: c539757d67b1b789ae476251c73835b90d2778c02ab4ad43239b6bca518716b8  264 bytes  1846 us
    #           rem <= rem::newaccount              {"creator":"remproducer2","name":"namevalidatr","owner":{"threshold":1,"keys":[{"key":"EOS6QRD67S2qR...
    #           rem <= rem::delegatebw              {"from":"remproducer2","receiver":"namevalidatr","stake_quantity":"1000.0000 REM","transfer":1}
    #     rem.token <= rem.token::transfer          {"from":"remproducer2","to":"rem.stake","quantity":"1000.0000 REM","memo":"stake bandwidth"}
    #  remproducer2 <= rem.token::transfer          {"from":"remproducer2","to":"rem.stake","quantity":"1000.0000 REM","memo":"stake bandwidth"}
    #     rem.stake <= rem.token::transfer          {"from":"remproducer2","to":"rem.stake","quantity":"1000.0000 REM","memo":"stake bandwidth"}

.. warning::
    Name ``namevalidatr`` may already be taken on ``Testchain``. You can choose any free name that matches these rules:
        - Can only contain the characters ``.abcdefghijklmnopqrstuvwxyz12345``. ``a-z`` (lowercase), ``1-5`` and ``.`` (period)
        - Must start with a letter
        - Must be 12 characters


Step 3: Deploy Smart Contract to Testchain
==========================================

.. note::
    There is no need to run a full node to develop smart contracts; it is enough to know the address of one of the network nodes.
    Information about the ``Remprotocol Testnet`` services we have already indicated
    `here <prerequisites.html#remprotocol-testnet>`_.

We will use the previously created contract `name_validator <smart-contract-structure.html>`_.

**Go to your contract directory and then:**

.. code-block:: console

    $ cd build

**Let's deploy a** ``name_validator`` **contract to** ``Testchain``:

.. code-block:: console

    $ remcli -u https://testchain.remme.io/ set contract namevalidatr name_validator

**It will return something like:**

.. code-block:: bash

    Publishing contract...
    executed transaction: b2123a1eae99ca2f926ae8d99c3fc7c5b815f185a48cbac9738de904ba851a00  2624 bytes  960 us
    #           rem <= rem::setcode                 {"account":"namevalidatr","vmtype":0,"vmversion":0,"code":"0061736d0100000001641260000060017e017f600...
    #           rem <= rem::setabi                  {"account":"namevalidatr","abi":"0e656f73696f3a3a6162692f312e3100010c76616c69646174656e616d650001087...

**Now, test it:**

.. code-block:: console

    $ remcli -u https://testchain.remme.io/ push action namevalidatr validatename '["newaccount12"]' -p namevalidatr

**It will return something like:**

.. code-block:: bash

    executed transaction: 77133a37a08649131a1e7df74e0507198b6e83dd1a906f7ddf2baf88d4c4d4c9  112 bytes  340 us
    #  namevalidatr <= namevalidatr::validatename   {"username":"newaccount12"}

.. tip::
    To not write ``remcli -u https://testchain.remme.io/ ..`` each time, you can add an alias
    ``alias remclit='remcli -u https://testchain.remme.io/'`` to ``bashrc``.
